<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="../../css/css-paper/paper.css">
    <title>About - pwnbuffer.org</title>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/xt256.min.css">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/x86asm.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/php.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/vbscript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/rust.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/powershell.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/json.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/yaml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/xml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/htmlbars.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/nginx.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/shell.min.js"></script>
  <script>
      hljs.highlightAll();
    //  hljs.configure({languages: []});
    </script>

</head>

<body>
    <div class="main_container">
        <header class="header_top">
            <div class="left-section">
                <a href="./a/about.html" class="menu-link">[ 0xAb0ut-Us ]</a>
                <a href="./c/contribute.html" class="menu-link">[ 0xContribut3 ]</a>
                <a href="./w/worms.html" class="menu-link">[ 0xW0rms ]</a>
            </div>
            <div class="right-section">
                <span class="glitch-text">0xPwnbuff3r</span>
            </div>

        </header>

        <main class="content">
            <h1 class="pwntitle">Buffer Overflow na prática</h1>
            <article>
                  <h1 id="o-que-é-buffer-overflow">O que é buffer
                  overflow?</h1>
                  <p>Buffer overflow (BOF) é uma das vulnerabilidades
                  mais conhecidas e historicamente significativas no
                  mundo da cibersegurança. Ele ocorre quando um programa
                  escreve mais dados em um buffer do que ele pode
                  armazenar, causando corrupção de memória. Essa falha
                  pode ser explorada por pentesters para executar código
                  arbitrário, modificar o comportamento do programa ou
                  causar um crash.</p>
                  <p>Apesar da introdução de mecanismos modernos de
                  segurança, como ASLR e stack canaries, o buffer
                  overflow continua sendo um tópico crítico no
                  desenvolvimento de exploits e pentesting. Compreender
                  como o BOF funciona, como detectá-lo e explorá-lo é
                  essencial.</p>
                  <p>Neste artigo, criaremos um programa simples em C,
                  propositalmente vulnerável, e um exploit em
                  Python.</p>
                  <h1 id="mãos-à-obra">Mãos à obra!</h1>
                  <p>Vamos lá! Para este artigo simples, criei um código
                  em C para praticarmos:</p>
                  <pre class="c"><code>#include &lt;stdio.h&gt;
#define _GNU_SOURCE
#include &lt;string.h&gt;

void secret() {
    printf(&quot;BOF explorado
&quot;);
}

void funcvuln() {
    char buffer[64];
    printf(&quot;input: &quot;);
    gets(buffer);
}

int main() {
    funcvuln();
    printf(&quot;.
&quot;);
    return 0;
}</code></pre>
                  <p>Este código é vulnerável a BOF devido ao uso da
                  função <code>gets()</code>, que não realiza
                  verificações de limite sobre a entrada fornecida. A
                  função <code>gets()</code> lê a entrada do usuário e a
                  armazena no buffer <code>char buffer[64]</code>. No
                  entanto, ela não verifica o tamanho da entrada. Se o
                  input exceder os 64 bytes alocados, ele sobrescreverá
                  locais adjacentes da memória, o que pode levar a um
                  comportamento imprevisível, incluindo a capacidade de
                  sobrescrever o endereço de retorno da função
                  <code>funcvuln()</code>. Se o usuário inserir mais de
                  64 caracteres, os caracteres extras transbordarão o
                  <code>buffer</code> e poderão sobrescrever o endereço
                  de retorno salvo na pilha. Isso pode permitir que um
                  invasor controle o fluxo do programa, redirecionando a
                  execução para a função <code>secret()</code>, que
                  imprime <code>BOF explorado</code>!</p>
                  <p>Para compilar o código de forma que ele permaneça
                  vulnerável ao BOF, precisamos garantir que as
                  proteções modernas do compilador, como SSP, DEP e
                  ASLR, estejam desativadas:
                  <code>gcc -fno-stack-protector -z noexecstack -std=gnu99 -o bof bof.c</code></p>
                  <p>Após compilar o binário, podemos ver que uma
                  mensagem de aviso aparece!</p>
                  <p><img src="/images/slayer/bof/error_gcc.png"
                  alt="Erro gcc" /></p>
                  <p>Também devemos desativar o ASLR para nossa sessão
                  atual:
                  <code>echo 0 | sudo tee /proc/sys/kernel/randomize_va_space</code></p>
                  <p>Agora, vamos finalmente explorar o BOF!</p>
                  <h1 id="exploração">Exploração!</h1>
                  <p>Mãos à obra! Vamos usar o gdb para analisar o
                  binário e entender melhor como ele se comporta na
                  memória. Isso nos ajudará a encontrar o deslocamento
                  correto para sobrescrever a função de retorno:
                  <code>gdb ./bof</code></p>
                  <p>A primeira coisa que fiz ao iniciar o gdb foi usar
                  <code>info functions</code> para listar as funções
                  presentes no binário:</p>
                  <p><img src="/images/slayer/bof/info_command.png"
                  alt="Comando" /></p>
                  <p>Agora que encontramos os endereços das funções,
                  vamos disparar o BOF e ver se há alguma alteração:</p>
                  <p><img src="/images/slayer/bof/BOOM.png"
                  alt="Comando" /></p>
                  <p>eee... BOOM! Transbordamos o buffer e recebemos um
                  <code>Segmentation fault.</code>! Depois disso,
                  listamos as funções novamente...</p>
                  <p><img src="/images/slayer/bof/secret.png"
                  alt="Comando" /></p>
                  <p>BOOYHA! O endereço da função que antes era
                  <code>0x0000000000001159</code> agora se tornou
                  <code>0x555555555159</code>! Usaremos esse novo
                  endereço para explorar! Para isso, criaremos um
                  exploit onde um payload será enviado, ultrapassando o
                  tamanho do buffer e sobrescrevendo o endereço de
                  retorno da função <code>funcvuln()</code>:</p>
                  <pre class="py"><code>from pwn import *

address = p64(0x0000555555555159)
payload = b&quot;A&quot; * 72 + address
p = process(&quot;./bof&quot;)
p.sendline(payload)
p.interactive()</code></pre>
                  <p>E aí está o exploit. Mas vamos entender como ele
                  funciona! Primeiro, ele importa as funções do pwntools
                  e define o endereço da função <code>secret()</code>. A
                  função <code>p64()</code> converte o endereço para o
                  formato de 64 bits, pois em sistemas de 64 bits, os
                  endereços de memória têm 8 bytes.</p>
                  <p>Após definir e converter o endereço, criamos o
                  payload. <code>b"A" * 72</code> cria uma string de 72
                  bytes contendo <code>'A'</code> para preencher a pilha
                  até o ponto onde o endereço de retorno da função
                  <code>funcvuln()</code> está armazenado, e
                  <code>+ address</code> adiciona o endereço da função
                  <code>secret()</code> no final, substituindo o
                  endereço de retorno de <code>funcvuln()</code>.</p>
                  <p>Agora que o exploit foi explicado, VAMOS
                  EXPLORAR!</p>
                  <p><img src="/images/slayer/bof/exploited.png"
                  alt="Comando" /></p>
                  <p>E como esperado, conseguimos explorar este BOF!
                  Este é um exemplo bem básico, apenas para demonstrar a
                  lógica prática de como um ataque de buffer overflow
                  pode acontecer ;)</p>
            </article>
            
            <a href="/PwnBuffer/index.html" class="back-link">← Voltar para a página principal</a>
        </main>

        <footer class="footer">
            <div class="footer-content">
                <span>&copy; 2025 - pwnbuffer.org </span>
                <span class="footer-separator">|</span>
                <a href="https://www.freebsd.org/" target="_blank" class="footer-link">[ Discord ]</a>
                <span class="footer-separator">|</span>
                <a href="https://github.com/" target="_blank" class="footer-link">[ X ] </a>
        </footer>
    </div>

</body>
<script>
    document.addEventListener("DOMContentLoaded", () => {
        const els = document.querySelectorAll(".glitch-text, .pwntitle");
        const chars = "\u0025\u0023\u0024\u0040\u005E\u0026\u002A\u0021\u003F\u003C\u002D\u003E\u002B\u007C\u002A";

        els.forEach(el => {
            const originalText = el.textContent;

            function glitchEffect() {
                let iterations = 0;
                const interval = setInterval(() => {
                    el.textContent = originalText
                        .split("")
                        .map((letter, index) => {
                            if (index < iterations) {
                                return originalText[index];
                            }
                            return chars[Math.floor(Math.random() * chars.length)];
                        })
                        .join("");

                    iterations += 1 / 2;

                    if (iterations >= originalText.length) {
                        clearInterval(interval);
                        el.textContent = originalText;
                    }
                }, 50);
            }

            setInterval(glitchEffect, 3000);
        });
    });
</script>

</html>
